# Architecture & Development Overview

This document outlines the architectural decisions, development process, and technical implementations for the Task Management Dashboard application.

---

## 1. Initial Scaffolding & Design

The application's foundation was generated using the **Angular CLI**. To accelerate the UI development process, we leveraged **Builder.io** to translate a Figma design directly into Angular components. This approach significantly streamlined the creation of the initial design system, including a functional **dark and light theme**, which served as a baseline for further refinement.

The initial output from this process consisted of two primary components, `task` and `main-layout`. These were then refactored and organized into a more robust and scalable structure.

---

## 2. Project Structure

To ensure maintainability and a clear separation of concerns, the project was organized into a modular folder structure, distinguishing between `pages` (smart components) and `components` (reusable UI components).

```
src/
│
├── app/
│   ├── components/       # Reusable UI components
│   │   ├── filter/
│   │   ├── sidebar/
│   │   ├── stats-cards/
│   │   └── table/
│   │
│   ├── layout-theme/     # Layout and visual theme
│   ├── models/           # Interfaces and type definitions
│   ├── pages/            # Main feature pages
│   │   ├── form-task-details/
│   │   ├── list-view/
│   │   ├── settings/
│   │   └── users/
│   │
│   ├── services/         # Business logic and state management
│   │
│   ├── app.config.ts
│   ├── app.html
│   ├── app.routes.ts
│   ├── app.scss
│   ├── app.spec.ts
│   ├── app.ts
│   ├── index.html
│   ├── main.ts
│   ├── styles.scss
│   └── test.ts
│
└── assets/               # Static assets (images, icons, etc.)
```

---

## 3. Data and State Management

The data layer was designed with modern reactive patterns. The services were structured to consume data from a **separate mock data file**, simulating a real-world API backend.

- **Reactive Primitives:** **Signals and RxJS Observables** are used in tandem to manage and propagate state changes throughout the application.

- **Centralized State:** State management is centralized within Angular services. This allows reactive data sources (Signals and Observables) to be reused across multiple components, promoting a single source of truth. A prime example is the filter mechanism.

- **Component Communication:** Communication between components is handled reactively via **Signal-based `input`s and `output`s**, enabling features like live filtering as the user types.

In a production environment, this pattern could be extended using a utility like `rx-resource` for handling API requests or by leveraging Observables for more complex asynchronous data flows.

---

## 4. Key Implementations & Refactoring

A significant effort was dedicated to refactoring and enhancing the code initially generated by Builder.io to align with modern Angular best practices.

- **Code Modernization:** The entire codebase was updated to use the latest Angular features, including the new built-in control flow (`@if`, `@for`) and Signal-based component I/O. Unnecessary tooltips were removed, and repeated code was abstracted into reusable functions.

- **Component Separation:** Components initially grouped together were logically separated into `pages` and `components`.

- **Typing:** TypeScript interfaces and constants were created to ensure strong typing and improve code quality.

- **Styling & Responsiveness:** UI elements like buttons and inputs were restyled for a more modern look and feel. The layout was adjusted to be fully responsive for mobile devices.

- **Functionality Fixes:** The collapsible sidebar, which was not functional post-generation, was re-implemented and fixed.

- **Routing:** A full routing implementation was added to enable navigation between different application views.

- **Accessibility (A11y):** All components were audited and updated with the necessary **ARIA attributes** to ensure full screen reader support and keyboard navigability.

---

## 5. Testing Approach & Challenges

- **Test Suite:** The project is configured with both **unit tests (Karma/Jasmine)** and **E2E tests (Playwright)**.

- **Zoneless Environment:** A key challenge was the absence of `zone.js`. This required adjusting the test setup, installing `@angular/platform-browser-dynamic`, and leveraging Angular's `provideZonelessChangeDetection()`.

- **Asynchronous Testing:** The main challenge in the zoneless environment was testing asynchronous RxJS operators like `debounceTime`, as `fakeAsync` is not available. This was solved by using `await new Promise` to manually manage the async flow in tests for the **Filter Component**.

---

## 6. Future Improvements

- **Authentication:** Implement a full authentication system with route guards.

- **Test Coverage:** Expand unit and E2E test coverage to all components.

- **Advanced State Management:** If the application complexity grows, introduce a dedicated state management library like NgRx.

- **UI Enhancements:** Implement features like infinite scrolling/pagination and skeleton loaders for improved UX.
